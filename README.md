# crud_mascotas_arquitectura_capas_python_oracle .

<img width="203" height="193" alt="image" src="https://github.com/user-attachments/assets/acd0ce8a-579d-497b-a76e-797430d0bb13" />  

# Programa: Almacén de Mascotas — Arquitectura por capas (Modelo / Repositorio / Servicio / Vista / Configuración)

Este documento contiene el programa completo en Python con arquitectura por capas que realiza un **CRUD de mascotas** y persiste la información en una base de datos **Oracle**. Incluye:

- DDL para crear la tabla en Oracle.
- Módulos Python (cada uno como archivo separado).
- Instrucciones para ejecutar y manejo de errores (si falla Oracle, guarda en `pets_backup.json` como respaldo).
- Ejemplos de uso y recomendaciones.

---

## Recomendaciones previas

- Python 3.10+.
- Instalar dependencias:

```bash
pip install oracledb python-dotenv tabulate
```

- Crear un archivo `.env` en la misma carpeta con:

```
ORACLE_USER=tu_usuario
ORACLE_PASS=tu_contraseña
ORACLE_DSN=localhost/XEPDB1   # o la string de conexión que uses
```

Ajusta `ORACLE_DSN` al servicio/host/puerto/servicio de tu Oracle.

---

## DDL — crear tabla en Oracle

Ejecuta esto en tu base Oracle (SQL*Plus, SQL Developer, etc.) :

```sql
CREATE TABLE mascotas (
  id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  nombre VARCHAR2(100) NOT NULL,
  especie VARCHAR2(50),
  raza VARCHAR2(80),
  edad NUMBER,
  peso NUMBER(6,2),
  fecha_ingreso DATE DEFAULT SYSDATE,
  observaciones VARCHAR2(4000)
);
```

> Nota: si prefieres usar SEQUENCE + TRIGGER puedes adaptar, pero la instrucción anterior usa `IDENTITY` para simplicidad.

---

## Estructura de archivos (sugerida)

```
config.py
model.py
repository.py
service.py
view.py
main.py
.env (no subir a repos remotos)
pets_backup.json (se crea automáticamente si no existe cuando el repo cae a respaldo)
```

---

## Contenido de cada archivo

### `config.py`

```python
# config.py
from dotenv import load_dotenv
import os
import oracledb

load_dotenv()

ORACLE_USER = os.getenv("ORACLE_USER")
ORACLE_PASS = os.getenv("ORACLE_PASS")
ORACLE_DSN  = os.getenv("ORACLE_DSN")

def get_connection():
    """
    Devuelve una conexión a Oracle. Lanza excepción si falla.
    """
    if not (ORACLE_USER and ORACLE_PASS and ORACLE_DSN):
        raise RuntimeError("Variables ORACLE_USER/ORACLE_PASS/ORACLE_DSN no configuradas en .env")
    # Si necesitas usar Oracle Instant Client, realiza oracledb.init_oracle_client(lib_dir=...) antes.
    return oracledb.connect(user=ORACLE_USER, password=ORACLE_PASS, dsn=ORACLE_DSN, encoding="UTF-8")
```

---

### `model.py`

```python
# model.py
from dataclasses import dataclass
from datetime import date
from typing import Optional

@dataclass
class Mascota:
    id: Optional[int] = None
    nombre: str = ""
    especie: Optional[str] = None
    raza: Optional[str] = None
    edad: Optional[int] = None
    peso: Optional[float] = None
    fecha_ingreso: Optional[date] = None
    observaciones: Optional[str] = None
```

---

### `repository.py` (DAO — acceso a Oracle y fallback a JSON)

```python
# repository.py
import json
from typing import List, Optional
from model import Mascota
from config import get_connection
from datetime import datetime
import os

BACKUP_FILE = "pets_backup.json"

class MascotaRepository:
    def __init__(self):
        self._use_db = True
        # probar conexión al iniciarse
        try:
            conn = get_connection()
            conn.close()
        except Exception as e:
            print(f"[WARN] No se pudo conectar a Oracle: {e}. Usando respaldo local ({BACKUP_FILE}).")
            self._use_db = False
            # asegurarse de que el archivo exista
            if not os.path.exists(BACKUP_FILE):
                with open(BACKUP_FILE, "w", encoding="utf-8") as f:
                    json.dump([], f, ensure_ascii=False, indent=2)

    # -----------------------
    # CRUD en Oracle
    # -----------------------
    def create(self, mascota: Mascota) -> Mascota:
        if not self._use_db:
            return self._create_local(mascota)
        conn = get_connection()
        try:
            with conn.cursor() as cur:
                sql = """
                INSERT INTO mascotas (nombre, especie, raza, edad, peso, fecha_ingreso, observaciones)
                VALUES (:nombre, :especie, :raza, :edad, :peso, :fecha_ingreso, :observaciones)
                """
                fecha = mascota.fecha_ingreso or datetime.now()
                cur.execute(sql, {
                    "nombre": mascota.nombre,
                    "especie": mascota.especie,
                    "raza": mascota.raza,
                    "edad": mascota.edad,
                    "peso": mascota.peso,
                    "fecha_ingreso": fecha,
                    "observaciones": mascota.observaciones
                })
                # Si quieres recuperar el ID generado usando RETURNING id INTO :rid,
                # es posible usar rid = cur.var(int) y cur.execute(..., rid=rid) — ver nota al final.
            conn.commit()
            return mascota
        except Exception as e:
            conn.rollback()
            print(f"[ERROR] Al crear en Oracle: {e}. Guardando en respaldo local.")
            self._use_db = False
            return self._create_local(mascota)
        finally:
            conn.close()

    def get_all(self) -> List[Mascota]:
        if not self._use_db:
            return self._get_all_local()
        conn = get_connection()
        mascotas = []
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT id, nombre, especie, raza, edad, peso, fecha_ingreso, observaciones FROM mascotas ORDER BY id")
                for r in cur:
                    m = Mascota(
                        id = int(r[0]) if r[0] is not None else None,
                        nombre = r[1],
                        especie = r[2],
                        raza = r[3],
                        edad = int(r[4]) if r[4] is not None else None,
                        peso = float(r[5]) if r[5] is not None else None,
                        fecha_ingreso = r[6],
                        observaciones = r[7]
                    )
                    mascotas.append(m)
            return mascotas
        except Exception as e:
            print(f"[ERROR] Al leer desde Oracle: {e}. Usando respaldo local.")
            self._use_db = False
            return self._get_all_local()
        finally:
            conn.close()

    def get_by_id(self, id_: int) -> Optional[Mascota]:
        if not self._use_db:
            return self._get_by_id_local(id_)
        conn = get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT id, nombre, especie, raza, edad, peso, fecha_ingreso, observaciones FROM mascotas WHERE id = :id", {"id": id_})
                r = cur.fetchone()
                if not r:
                    return None
                return Mascota(
                    id = int(r[0]),
                    nombre = r[1],
                    especie = r[2],
                    raza = r[3],
                    edad = int(r[4]) if r[4] is not None else None,
                    peso = float(r[5]) if r[5] is not None else None,
                    fecha_ingreso = r[6],
                    observaciones = r[7]
                )
        except Exception as e:
            print(f"[ERROR] Al obtener por id desde Oracle: {e}.")
            self._use_db = False
            return self._get_by_id_local(id_)
        finally:
            conn.close()

    def update(self, mascota: Mascota) -> bool:
        if not self._use_db:
            return self._update_local(mascota)
        conn = get_connection()
        try:
            with conn.cursor() as cur:
                sql = """
                UPDATE mascotas
                SET nombre = :nombre, especie = :especie, raza = :raza, edad = :edad, peso = :peso, observaciones = :observaciones
                WHERE id = :id
                """
                cur.execute(sql, {
                    "nombre": mascota.nombre,
                    "especie": mascota.especie,
                    "raza": mascota.raza,
                    "edad": mascota.edad,
                    "peso": mascota.peso,
                    "observaciones": mascota.observaciones,
                    "id": mascota.id
                })
            conn.commit()
            return cur.rowcount > 0
        except Exception as e:
            conn.rollback()
            print(f"[ERROR] Al actualizar en Oracle: {e}. Intentando respaldo local.")
            self._use_db = False
            return self._update_local(mascota)
        finally:
            conn.close()

    def delete(self, id_: int) -> bool:
        if not self._use_db:
            return self._delete_local(id_)
        conn = get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("DELETE FROM mascotas WHERE id = :id", {"id": id_})
            conn.commit()
            return cur.rowcount > 0
        except Exception as e:
            conn.rollback()
            print(f"[ERROR] Al eliminar en Oracle: {e}. Usando respaldo local.")
            self._use_db = False
            return self._delete_local(id_)
        finally:
            conn.close()

    # -----------------------
    # Backup local JSON (respaldo)
    # -----------------------
    def _read_backup(self):
        try:
            with open(BACKUP_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return []

    def _write_backup(self, data):
        with open(BACKUP_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    def _create_local(self, mascota: Mascota) -> Mascota:
        data = self._read_backup()
        new_id = (max((item.get("id", 0) for item in data), default=0) + 1) if data else 1
        obj = {
            "id": new_id,
            "nombre": mascota.nombre,
            "especie": mascota.especie,
            "raza": mascota.raza,
            "edad": mascota.edad,
            "peso": mascota.peso,
            "fecha_ingreso": datetime.now().isoformat(),
            "observaciones": mascota.observaciones
        }
        data.append(obj)
        self._write_backup(data)
        mascota.id = new_id
        return mascota

    def _get_all_local(self):
        data = self._read_backup()
        result = []
        for r in data:
            m = Mascota(
                id = r.get("id"),
                nombre = r.get("nombre"),
                especie = r.get("especie"),
                raza = r.get("raza"),
                edad = r.get("edad"),
                peso = r.get("peso"),
                fecha_ingreso = r.get("fecha_ingreso"),
                observaciones = r.get("observaciones")
            )
            result.append(m)
        return result

    def _get_by_id_local(self, id_):
        data = self._read_backup()
        for r in data:
            if int(r.get("id")) == int(id_):
                return Mascota(
                    id = r.get("id"),
                    nombre = r.get("nombre"),
                    especie = r.get("especie"),
                    raza = r.get("raza"),
                    edad = r.get("edad"),
                    peso = r.get("peso"),
                    fecha_ingreso = r.get("fecha_ingreso"),
                    observaciones = r.get("observaciones")
                )
        return None

    def _update_local(self, mascota: Mascota) -> bool:
        data = self._read_backup()
        updated = False
        for i, r in enumerate(data):
            if int(r.get("id")) == int(mascota.id):
                data[i].update({
                    "nombre": mascota.nombre,
                    "especie": mascota.especie,
                    "raza": mascota.raza,
                    "edad": mascota.edad,
                    "peso": mascota.peso,
                    "observaciones": mascota.observaciones
                })
                updated = True
                break
        if updated:
            self._write_backup(data)
        return updated

    def _delete_local(self, id_) -> bool:
        data = self._read_backup()
        new = [r for r in data if int(r.get("id")) != int(id_)]
        if len(new) == len(data):
            return False
        self._write_backup(new)
        return True
```

> Nota: en `create` dejé la inserción simple y fallback al archivo local cuando Oracle no responde. Si quieres que el `INSERT` devuelva el ID generado usando `RETURNING id INTO :rid`, se puede adaptar (requiere `cursor.var(int)` en `oracledb`).

---

### `service.py`

```python
# service.py
from repository import MascotaRepository
from model import Mascota

class MascotaService:
    def __init__(self):
        self.repo = MascotaRepository()

    def crear_mascota(self, data: dict) -> Mascota:
        m = Mascota(
            nombre = data.get("nombre"),
            especie = data.get("especie"),
            raza = data.get("raza"),
            edad = int(data["edad"]) if data.get("edad") else None,
            peso = float(data["peso"]) if data.get("peso") else None,
            observaciones = data.get("observaciones")
        )
        return self.repo.create(m)

    def listar_mascotas(self):
        return self.repo.get_all()

    def obtener_mascota(self, id_):
        return self.repo.get_by_id(id_)

    def actualizar_mascota(self, id_, data: dict) -> bool:
        existing = self.repo.get_by_id(id_)
        if not existing:
            return False
        # actualizar campos si vienen en data
        existing.nombre = data.get("nombre", existing.nombre)
        existing.especie = data.get("especie", existing.especie)
        existing.raza = data.get("raza", existing.raza)
        existing.edad = int(data["edad"]) if data.get("edad") else existing.edad
        existing.peso = float(data["peso"]) if data.get("peso") else existing.peso
        existing.observaciones = data.get("observaciones", existing.observaciones)
        return self.repo.update(existing)

    def eliminar_mascota(self, id_):
        return self.repo.delete(id_)
```

---

### `view.py` (Interfaz de consola / CLI)

```python
# view.py
from service import MascotaService
from tabulate import tabulate

svc = MascotaService()

def input_non_empty(prompt):
    while True:
        v = input(prompt).strip()
        if v:
            return v

def mostrar_menu():
    print("\n=== Almacén de Mascotas ===")
    print("1) Listar mascotas")
    print("2) Crear mascota")
    print("3) Ver mascota por ID")
    print("4) Actualizar mascota")
    print("5) Eliminar mascota")
    print("0) Salir")

def listar():
    mascotas = svc.listar_mascotas()
    if not mascotas:
        print("No hay mascotas registradas.")
        return
    table = []
    for m in mascotas:
        table.append([m.id, m.nombre, m.especie, m.raza, m.edad, m.peso, getattr(m, "fecha_ingreso", "")])
    print(tabulate(table, headers=["ID","Nombre","Especie","Raza","Edad","Peso","Fecha ingreso"], tablefmt="grid"))

def crear():
    print("Crear nueva mascota:")
    nombre = input_non_empty("Nombre: ")
    especie = input("Especie: ").strip()
    raza = input("Raza: ").strip()
    edad = input("Edad (número): ").strip()
    peso = input("Peso (kg): ").strip()
    obs = input("Observaciones: ").strip()
    data = {
        "nombre": nombre,
        "especie": especie or None,
        "raza": raza or None,
        "edad": int(edad) if edad else None,
        "peso": float(peso) if peso else None,
        "observaciones": obs or None
    }
    m = svc.crear_mascota(data)
    print(f"Mascota creada (id={m.id}).")

def ver_por_id():
    id_ = input_non_empty("ID de la mascota: ")
    m = svc.obtener_mascota(int(id_))
    if not m:
        print("Mascota no encontrada.")
        return
    print("Detalles:")
    for k, v in m.__dict__.items():
        print(f"  {k}: {v}")

def actualizar():
    id_ = input_non_empty("ID a actualizar: ")
    m = svc.obtener_mascota(int(id_))
    if not m:
        print("No existe mascota con ese ID.")
        return
    print("Dejar vacío para mantener el valor actual.")
    nombre = input(f"Nombre [{m.nombre}]: ").strip() or m.nombre
    especie = input(f"Especie [{m.especie}]: ").strip() or m.especie
    raza = input(f"Raza [{m.raza}]: ").strip() or m.raza
    edad = input(f"Edad [{m.edad}]: ").strip()
    peso = input(f"Peso [{m.peso}]: ").strip()
    obs = input(f"Observaciones [{m.observaciones}]: ").strip() or m.observaciones
    data = {
        "nombre": nombre,
        "especie": especie,
        "raza": raza,
        "edad": int(edad) if edad else m.edad,
        "peso": float(peso) if peso else m.peso,
        "observaciones": obs
    }
    ok = svc.actualizar_mascota(int(id_), data)
    print("Actualizado." if ok else "No se pudo actualizar.")

def eliminar():
    id_ = input_non_empty("ID a eliminar: ")
    ok = svc.eliminar_mascota(int(id_))
    print("Eliminado." if ok else "No encontrado o no se pudo eliminar.")

def run_cli():
    while True:
        mostrar_menu()
        op = input("Selecciona opción: ").strip()
        if op == "1":
            listar()
        elif op == "2":
            crear()
        elif op == "3":
            ver_por_id()
        elif op == "4":
            actualizar()
        elif op == "5":
            eliminar()
        elif op == "0":
            print("Saliendo. ¡Hasta luego!")
            break
        else:
            print("Opción inválida.")
```

---

### `main.py`

```python
# main.py
from view import run_cli

if __name__ == "__main__":
    run_cli()
```

---

## Notas y mejoras sugeridas

- **Obtener ID en INSERT:** si tu tabla usa una `SEQUENCE` (o `IDENTITY`), es mejor usar `RETURNING id INTO :rid` con `rid = cursor.var(int)` para recuperar el id inmediatamente. Puedo adaptar `repository.create` para usar `RETURNING` si lo deseas.

- **Conexión con Instant Client:** si tienes problemas de librerías nativas, instala Oracle Instant Client y llama a `oracledb.init_oracle_client(lib_dir=...)` antes de conectar (solo si corresponde).

- **Validaciones:** la capa `service` hace validaciones mínimas; puedes añadir validaciones más estrictas (p. ej. `edad >= 0`, `nombre` obligatorio con longitud, restricciones de `peso`, etc.).

- **Interfaz:** si prefieres GUI (Tkinter) o una API REST (Flask/FastAPI) en lugar de CLI, puedo generar esa capa vista también.

- **Manejo transaccional avanzado:** aquí cada operación hace `commit` individual; si necesitas transacciones compuestas, podemos exponer control de transacciones en el repo.

---

## Ejemplos de uso (rápido)

1. Coloca `.env` con credenciales.
2. Crea la tabla en Oracle con el DDL proporcionado.
3. Ejecuta:

```bash
python main.py
```

4. Usa la interfaz para crear, listar, actualizar y borrar mascotas.

---

Si quieres, puedo adaptar el proyecto para:

- Devolver el `id` insertado usando `RETURNING`.
- Un endpoint REST en Flask/FastAPI.
- Una interfaz gráfica con Tkinter.
